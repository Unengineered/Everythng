// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'marketplace.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MarketplaceTearOff {
  const _$MarketplaceTearOff();

  _Renting renting() {
    return const _Renting();
  }

  _Thrifting thrifting() {
    return const _Thrifting();
  }

  _Buying buying() {
    return const _Buying();
  }

  _Store store() {
    return const _Store();
  }
}

/// @nodoc
const $Marketplace = _$MarketplaceTearOff();

/// @nodoc
mixin _$Marketplace {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() renting,
    required TResult Function() thrifting,
    required TResult Function() buying,
    required TResult Function() store,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Renting value) renting,
    required TResult Function(_Thrifting value) thrifting,
    required TResult Function(_Buying value) buying,
    required TResult Function(_Store value) store,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MarketplaceCopyWith<$Res> {
  factory $MarketplaceCopyWith(
          Marketplace value, $Res Function(Marketplace) then) =
      _$MarketplaceCopyWithImpl<$Res>;
}

/// @nodoc
class _$MarketplaceCopyWithImpl<$Res> implements $MarketplaceCopyWith<$Res> {
  _$MarketplaceCopyWithImpl(this._value, this._then);

  final Marketplace _value;
  // ignore: unused_field
  final $Res Function(Marketplace) _then;
}

/// @nodoc
abstract class _$RentingCopyWith<$Res> {
  factory _$RentingCopyWith(_Renting value, $Res Function(_Renting) then) =
      __$RentingCopyWithImpl<$Res>;
}

/// @nodoc
class __$RentingCopyWithImpl<$Res> extends _$MarketplaceCopyWithImpl<$Res>
    implements _$RentingCopyWith<$Res> {
  __$RentingCopyWithImpl(_Renting _value, $Res Function(_Renting) _then)
      : super(_value, (v) => _then(v as _Renting));

  @override
  _Renting get _value => super._value as _Renting;
}

/// @nodoc

class _$_Renting implements _Renting {
  const _$_Renting();

  @override
  String toString() {
    return 'Marketplace.renting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Renting);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() renting,
    required TResult Function() thrifting,
    required TResult Function() buying,
    required TResult Function() store,
  }) {
    return renting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
  }) {
    return renting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
    required TResult orElse(),
  }) {
    if (renting != null) {
      return renting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Renting value) renting,
    required TResult Function(_Thrifting value) thrifting,
    required TResult Function(_Buying value) buying,
    required TResult Function(_Store value) store,
  }) {
    return renting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
  }) {
    return renting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
    required TResult orElse(),
  }) {
    if (renting != null) {
      return renting(this);
    }
    return orElse();
  }
}

abstract class _Renting implements Marketplace {
  const factory _Renting() = _$_Renting;
}

/// @nodoc
abstract class _$ThriftingCopyWith<$Res> {
  factory _$ThriftingCopyWith(
          _Thrifting value, $Res Function(_Thrifting) then) =
      __$ThriftingCopyWithImpl<$Res>;
}

/// @nodoc
class __$ThriftingCopyWithImpl<$Res> extends _$MarketplaceCopyWithImpl<$Res>
    implements _$ThriftingCopyWith<$Res> {
  __$ThriftingCopyWithImpl(_Thrifting _value, $Res Function(_Thrifting) _then)
      : super(_value, (v) => _then(v as _Thrifting));

  @override
  _Thrifting get _value => super._value as _Thrifting;
}

/// @nodoc

class _$_Thrifting implements _Thrifting {
  const _$_Thrifting();

  @override
  String toString() {
    return 'Marketplace.thrifting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Thrifting);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() renting,
    required TResult Function() thrifting,
    required TResult Function() buying,
    required TResult Function() store,
  }) {
    return thrifting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
  }) {
    return thrifting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
    required TResult orElse(),
  }) {
    if (thrifting != null) {
      return thrifting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Renting value) renting,
    required TResult Function(_Thrifting value) thrifting,
    required TResult Function(_Buying value) buying,
    required TResult Function(_Store value) store,
  }) {
    return thrifting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
  }) {
    return thrifting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
    required TResult orElse(),
  }) {
    if (thrifting != null) {
      return thrifting(this);
    }
    return orElse();
  }
}

abstract class _Thrifting implements Marketplace {
  const factory _Thrifting() = _$_Thrifting;
}

/// @nodoc
abstract class _$BuyingCopyWith<$Res> {
  factory _$BuyingCopyWith(_Buying value, $Res Function(_Buying) then) =
      __$BuyingCopyWithImpl<$Res>;
}

/// @nodoc
class __$BuyingCopyWithImpl<$Res> extends _$MarketplaceCopyWithImpl<$Res>
    implements _$BuyingCopyWith<$Res> {
  __$BuyingCopyWithImpl(_Buying _value, $Res Function(_Buying) _then)
      : super(_value, (v) => _then(v as _Buying));

  @override
  _Buying get _value => super._value as _Buying;
}

/// @nodoc

class _$_Buying implements _Buying {
  const _$_Buying();

  @override
  String toString() {
    return 'Marketplace.buying()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Buying);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() renting,
    required TResult Function() thrifting,
    required TResult Function() buying,
    required TResult Function() store,
  }) {
    return buying();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
  }) {
    return buying?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
    required TResult orElse(),
  }) {
    if (buying != null) {
      return buying();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Renting value) renting,
    required TResult Function(_Thrifting value) thrifting,
    required TResult Function(_Buying value) buying,
    required TResult Function(_Store value) store,
  }) {
    return buying(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
  }) {
    return buying?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
    required TResult orElse(),
  }) {
    if (buying != null) {
      return buying(this);
    }
    return orElse();
  }
}

abstract class _Buying implements Marketplace {
  const factory _Buying() = _$_Buying;
}

/// @nodoc
abstract class _$StoreCopyWith<$Res> {
  factory _$StoreCopyWith(_Store value, $Res Function(_Store) then) =
      __$StoreCopyWithImpl<$Res>;
}

/// @nodoc
class __$StoreCopyWithImpl<$Res> extends _$MarketplaceCopyWithImpl<$Res>
    implements _$StoreCopyWith<$Res> {
  __$StoreCopyWithImpl(_Store _value, $Res Function(_Store) _then)
      : super(_value, (v) => _then(v as _Store));

  @override
  _Store get _value => super._value as _Store;
}

/// @nodoc

class _$_Store implements _Store {
  const _$_Store();

  @override
  String toString() {
    return 'Marketplace.store()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Store);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() renting,
    required TResult Function() thrifting,
    required TResult Function() buying,
    required TResult Function() store,
  }) {
    return store();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
  }) {
    return store?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? renting,
    TResult Function()? thrifting,
    TResult Function()? buying,
    TResult Function()? store,
    required TResult orElse(),
  }) {
    if (store != null) {
      return store();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Renting value) renting,
    required TResult Function(_Thrifting value) thrifting,
    required TResult Function(_Buying value) buying,
    required TResult Function(_Store value) store,
  }) {
    return store(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
  }) {
    return store?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Renting value)? renting,
    TResult Function(_Thrifting value)? thrifting,
    TResult Function(_Buying value)? buying,
    TResult Function(_Store value)? store,
    required TResult orElse(),
  }) {
    if (store != null) {
      return store(this);
    }
    return orElse();
  }
}

abstract class _Store implements Marketplace {
  const factory _Store() = _$_Store;
}
