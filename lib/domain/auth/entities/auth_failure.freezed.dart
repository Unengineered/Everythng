// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AuthFailureTearOff {
  const _$AuthFailureTearOff();

  UserDisabled userDisabled() {
    return const UserDisabled();
  }

  IncorrectPassword incorrectPassword() {
    return const IncorrectPassword();
  }

  AccountBlocked accountBlocked() {
    return const AccountBlocked();
  }

  InvalidUser invalidUser() {
    return const InvalidUser();
  }

  Unauthenticated unauthenticated() {
    return const Unauthenticated();
  }

  ServerError serverError() {
    return const ServerError();
  }

  InvalidFailure invalidFailure() {
    return const InvalidFailure();
  }
}

/// @nodoc
const $AuthFailure = _$AuthFailureTearOff();

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res> implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure _value;
  // ignore: unused_field
  final $Res Function(AuthFailure) _then;
}

/// @nodoc
abstract class $UserDisabledCopyWith<$Res> {
  factory $UserDisabledCopyWith(
          UserDisabled value, $Res Function(UserDisabled) then) =
      _$UserDisabledCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserDisabledCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $UserDisabledCopyWith<$Res> {
  _$UserDisabledCopyWithImpl(
      UserDisabled _value, $Res Function(UserDisabled) _then)
      : super(_value, (v) => _then(v as UserDisabled));

  @override
  UserDisabled get _value => super._value as UserDisabled;
}

/// @nodoc

class _$UserDisabled implements UserDisabled {
  const _$UserDisabled();

  @override
  String toString() {
    return 'AuthFailure.userDisabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UserDisabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return userDisabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return userDisabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (userDisabled != null) {
      return userDisabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return userDisabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return userDisabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (userDisabled != null) {
      return userDisabled(this);
    }
    return orElse();
  }
}

abstract class UserDisabled implements AuthFailure {
  const factory UserDisabled() = _$UserDisabled;
}

/// @nodoc
abstract class $IncorrectPasswordCopyWith<$Res> {
  factory $IncorrectPasswordCopyWith(
          IncorrectPassword value, $Res Function(IncorrectPassword) then) =
      _$IncorrectPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class _$IncorrectPasswordCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements $IncorrectPasswordCopyWith<$Res> {
  _$IncorrectPasswordCopyWithImpl(
      IncorrectPassword _value, $Res Function(IncorrectPassword) _then)
      : super(_value, (v) => _then(v as IncorrectPassword));

  @override
  IncorrectPassword get _value => super._value as IncorrectPassword;
}

/// @nodoc

class _$IncorrectPassword implements IncorrectPassword {
  const _$IncorrectPassword();

  @override
  String toString() {
    return 'AuthFailure.incorrectPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is IncorrectPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return incorrectPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return incorrectPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (incorrectPassword != null) {
      return incorrectPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return incorrectPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return incorrectPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (incorrectPassword != null) {
      return incorrectPassword(this);
    }
    return orElse();
  }
}

abstract class IncorrectPassword implements AuthFailure {
  const factory IncorrectPassword() = _$IncorrectPassword;
}

/// @nodoc
abstract class $AccountBlockedCopyWith<$Res> {
  factory $AccountBlockedCopyWith(
          AccountBlocked value, $Res Function(AccountBlocked) then) =
      _$AccountBlockedCopyWithImpl<$Res>;
}

/// @nodoc
class _$AccountBlockedCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $AccountBlockedCopyWith<$Res> {
  _$AccountBlockedCopyWithImpl(
      AccountBlocked _value, $Res Function(AccountBlocked) _then)
      : super(_value, (v) => _then(v as AccountBlocked));

  @override
  AccountBlocked get _value => super._value as AccountBlocked;
}

/// @nodoc

class _$AccountBlocked implements AccountBlocked {
  const _$AccountBlocked();

  @override
  String toString() {
    return 'AuthFailure.accountBlocked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is AccountBlocked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return accountBlocked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return accountBlocked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (accountBlocked != null) {
      return accountBlocked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return accountBlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return accountBlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (accountBlocked != null) {
      return accountBlocked(this);
    }
    return orElse();
  }
}

abstract class AccountBlocked implements AuthFailure {
  const factory AccountBlocked() = _$AccountBlocked;
}

/// @nodoc
abstract class $InvalidUserCopyWith<$Res> {
  factory $InvalidUserCopyWith(
          InvalidUser value, $Res Function(InvalidUser) then) =
      _$InvalidUserCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidUserCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $InvalidUserCopyWith<$Res> {
  _$InvalidUserCopyWithImpl(
      InvalidUser _value, $Res Function(InvalidUser) _then)
      : super(_value, (v) => _then(v as InvalidUser));

  @override
  InvalidUser get _value => super._value as InvalidUser;
}

/// @nodoc

class _$InvalidUser implements InvalidUser {
  const _$InvalidUser();

  @override
  String toString() {
    return 'AuthFailure.invalidUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is InvalidUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return invalidUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return invalidUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (invalidUser != null) {
      return invalidUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return invalidUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return invalidUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (invalidUser != null) {
      return invalidUser(this);
    }
    return orElse();
  }
}

abstract class InvalidUser implements AuthFailure {
  const factory InvalidUser() = _$InvalidUser;
}

/// @nodoc
abstract class $UnauthenticatedCopyWith<$Res> {
  factory $UnauthenticatedCopyWith(
          Unauthenticated value, $Res Function(Unauthenticated) then) =
      _$UnauthenticatedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnauthenticatedCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements $UnauthenticatedCopyWith<$Res> {
  _$UnauthenticatedCopyWithImpl(
      Unauthenticated _value, $Res Function(Unauthenticated) _then)
      : super(_value, (v) => _then(v as Unauthenticated));

  @override
  Unauthenticated get _value => super._value as Unauthenticated;
}

/// @nodoc

class _$Unauthenticated implements Unauthenticated {
  const _$Unauthenticated();

  @override
  String toString() {
    return 'AuthFailure.unauthenticated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Unauthenticated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return unauthenticated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return unauthenticated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return unauthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return unauthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated(this);
    }
    return orElse();
  }
}

abstract class Unauthenticated implements AuthFailure {
  const factory Unauthenticated() = _$Unauthenticated;
}

/// @nodoc
abstract class $ServerErrorCopyWith<$Res> {
  factory $ServerErrorCopyWith(
          ServerError value, $Res Function(ServerError) then) =
      _$ServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$ServerErrorCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $ServerErrorCopyWith<$Res> {
  _$ServerErrorCopyWithImpl(
      ServerError _value, $Res Function(ServerError) _then)
      : super(_value, (v) => _then(v as ServerError));

  @override
  ServerError get _value => super._value as ServerError;
}

/// @nodoc

class _$ServerError implements ServerError {
  const _$ServerError();

  @override
  String toString() {
    return 'AuthFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements AuthFailure {
  const factory ServerError() = _$ServerError;
}

/// @nodoc
abstract class $InvalidFailureCopyWith<$Res> {
  factory $InvalidFailureCopyWith(
          InvalidFailure value, $Res Function(InvalidFailure) then) =
      _$InvalidFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidFailureCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements $InvalidFailureCopyWith<$Res> {
  _$InvalidFailureCopyWithImpl(
      InvalidFailure _value, $Res Function(InvalidFailure) _then)
      : super(_value, (v) => _then(v as InvalidFailure));

  @override
  InvalidFailure get _value => super._value as InvalidFailure;
}

/// @nodoc

class _$InvalidFailure implements InvalidFailure {
  const _$InvalidFailure();

  @override
  String toString() {
    return 'AuthFailure.invalidFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is InvalidFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDisabled,
    required TResult Function() incorrectPassword,
    required TResult Function() accountBlocked,
    required TResult Function() invalidUser,
    required TResult Function() unauthenticated,
    required TResult Function() serverError,
    required TResult Function() invalidFailure,
  }) {
    return invalidFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
  }) {
    return invalidFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDisabled,
    TResult Function()? incorrectPassword,
    TResult Function()? accountBlocked,
    TResult Function()? invalidUser,
    TResult Function()? unauthenticated,
    TResult Function()? serverError,
    TResult Function()? invalidFailure,
    required TResult orElse(),
  }) {
    if (invalidFailure != null) {
      return invalidFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDisabled value) userDisabled,
    required TResult Function(IncorrectPassword value) incorrectPassword,
    required TResult Function(AccountBlocked value) accountBlocked,
    required TResult Function(InvalidUser value) invalidUser,
    required TResult Function(Unauthenticated value) unauthenticated,
    required TResult Function(ServerError value) serverError,
    required TResult Function(InvalidFailure value) invalidFailure,
  }) {
    return invalidFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
  }) {
    return invalidFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDisabled value)? userDisabled,
    TResult Function(IncorrectPassword value)? incorrectPassword,
    TResult Function(AccountBlocked value)? accountBlocked,
    TResult Function(InvalidUser value)? invalidUser,
    TResult Function(Unauthenticated value)? unauthenticated,
    TResult Function(ServerError value)? serverError,
    TResult Function(InvalidFailure value)? invalidFailure,
    required TResult orElse(),
  }) {
    if (invalidFailure != null) {
      return invalidFailure(this);
    }
    return orElse();
  }
}

abstract class InvalidFailure implements AuthFailure {
  const factory InvalidFailure() = _$InvalidFailure;
}
